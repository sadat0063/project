// ==================================================
// ZIP Generator - Advanced Multi-Format Archive
// ==================================================

class ZIPGenerator {
    constructor() {
        this.exportManager = null;
    }

    async generate(data, timestamp, options = {}) {
        try {
            console.log('ðŸ“¦ Generating ZIP archive...');
            
            // Load JSZip library
            if (typeof JSZip === 'undefined') {
                await this.loadJSZip();
            }
            
            const zip = new JSZip();
            const baseName = `chatsavepro-export-${timestamp}`;
            
            // Add multiple formats to ZIP
            await this.addFormatsToZip(zip, data, baseName, options);
            
            // Add README file
            await this.addReadmeFile(zip, data, baseName);
            
            // Add statistics file
            await this.addStatisticsFile(zip, data, baseName);
            
            // Generate ZIP content
            const zipContent = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 }
            });
            
            const filename = `${baseName}.zip`;
            
            console.log('âœ… ZIP archive created successfully');
            return {
                content: zipContent,
                filename: filename,
                mimeType: 'application/zip',
                format: 'zip',
                fileCount: Object.keys(zip.files).length
            };
            
        } catch (error) {
            console.error('âŒ ZIP generation failed:', error);
            throw new Error(`ZIP generation failed: ${error.message}`);
        }
    }

    async addFormatsToZip(zip, data, baseName, options) {
        const formats = options.formats || ['json', 'csv', 'txt', 'html', 'pdf'];
        const exportManager = new ExportManager();
        
        for (const format of formats) {
            try {
                const result = await exportManager.exportData(data, format);
                zip.file(`${baseName}/${baseName}.${format}`, result.content);
                console.log(`âœ… Added ${format.toUpperCase()} to ZIP`);
            } catch (error) {
                console.warn(`âš ï¸ Failed to add ${format} to ZIP:`, error);
            }
        }
    }

    async addReadmeFile(zip, data, baseName) {
        const readmeContent = this.generateReadmeContent(data, baseName);
        zip.file(`${baseName}/README.txt`, readmeContent);
    }

    async addStatisticsFile(zip, data, baseName) {
        const statsContent = this.generateStatisticsContent(data);
        zip.file(`${baseName}/STATISTICS.json`, JSON.stringify(statsContent, null, 2));
    }

    generateReadmeContent(data, baseName) {
        return `ChatSavePro Export Archive
===============================

Archive: ${baseName}.zip
Generated: ${new Date().toLocaleString()}
Version: 3.1.0

CONTENTS
--------
This ZIP archive contains your chat data in multiple formats:

1. ${baseName}.json    - Complete data in JSON format
2. ${baseName}.csv     - Tabular data in CSV format  
3. ${baseName}.txt     - Human-readable text report
4. ${baseName}.html    - Web-friendly HTML report
5. ${baseName}.pdf     - Printable PDF document
6. STATISTICS.json    - Detailed statistics and analytics

STATISTICS SUMMARY
------------------
Total Scans: ${data.scanResults.length}
Deep Scans: ${data.statistics.deepScans}
Live Scans: ${data.statistics.liveScans}
Platforms: ${Object.keys(data.statistics.platforms).join(', ')}

PLATFORM DISTRIBUTION
---------------------
${Object.entries(data.statistics.platforms)
    .map(([platform, count]) => `- ${platform}: ${count} scans`)
    .join('\n')}

RECENT SCANS
------------
${data.scanResults.slice(0, 5)
    .map((scan, i) => `${i + 1}. ${scan.platform} - ${scan.messageCount} messages - ${new Date(scan.timestamp).toLocaleString()}`)
    .join('\n')}

EXPORT INFORMATION
------------------
- Generated by: ChatSavePro Browser Extension
- Export Version: 3.1.0 (Advanced)
- Data Source: ${data.scanResults.length > 0 ? data.scanResults[0].url : 'Multiple sources'}
- Export Date: ${new Date().toISOString()}

For support or questions, please refer to the ChatSavePro documentation.
`;
    }

    generateStatisticsContent(data) {
        return {
            summary: {
                totalScans: data.scanResults.length,
                deepScans: data.statistics.deepScans,
                liveScans: data.statistics.liveScans,
                totalMessages: data.scanResults.reduce((sum, scan) => sum + (scan.messageCount || 0), 0),
                dateRange: {
                    start: new Date(Math.min(...data.scanResults.map(s => s.timestamp))).toISOString(),
                    end: new Date(Math.max(...data.scanResults.map(s => s.timestamp))).toISOString()
                }
            },
            platforms: data.statistics.platforms,
            scanTypes: {
                deep: data.scanResults.filter(s => s.scanType === 'deep').length,
                live: data.scanResults.filter(s => s.scanType === 'live').length
            },
            performance: {
                averageScanDuration: this.calculateAverageDuration(data),
                mostActivePlatform: this.findMostActivePlatform(data),
                scanFrequency: this.calculateScanFrequency(data)
            },
            exportInfo: {
                version: '3.1.0',
                generated: new Date().toISOString(),
                formatsIncluded: ['json', 'csv', 'txt', 'html', 'pdf', 'statistics']
            }
        };
    }

    calculateAverageDuration(data) {
        const durations = data.scanResults
            .map(scan => scan.data?.performance?.scanDuration)
            .filter(duration => duration && duration > 0);
        
        return durations.length > 0 
            ? Math.round(durations.reduce((a, b) => a + b, 0) / durations.length)
            : 0;
    }

    findMostActivePlatform(data) {
        const platformCounts = data.statistics.platforms;
        return Object.keys(platformCounts).reduce((a, b) => 
            platformCounts[a] > platformCounts[b] ? a : b
        );
    }

    calculateScanFrequency(data) {
        const scansByDate = {};
        data.scanResults.forEach(scan => {
            const date = new Date(scan.timestamp).toDateString();
            scansByDate[date] = (scansByDate[date] || 0) + 1;
        });
        return scansByDate;
    }

    async loadJSZip() {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = chrome.runtime.getURL('lib/jszip.min.js');
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
}